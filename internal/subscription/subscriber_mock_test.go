// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package subscription

import (
	"sync"
)

// Ensure, that SubscriberMock does implement Subscriber.
// If this is not the case, regenerate this file with moq.
var _ Subscriber = &SubscriberMock{}

// SubscriberMock is a mock implementation of Subscriber.
//
//	func TestSomethingThatUsesSubscriber(t *testing.T) {
//
//		// make and configure a mocked Subscriber
//		mockedSubscriber := &SubscriberMock{
//			SendEmailsFunc: func() error {
//				panic("mock out the SendEmails method")
//			},
//			SubscribeFunc: func(email Email) error {
//				panic("mock out the Subscribe method")
//			},
//		}
//
//		// use mockedSubscriber in code that requires Subscriber
//		// and then make assertions.
//
//	}
type SubscriberMock struct {
	// SendEmailsFunc mocks the SendEmails method.
	SendEmailsFunc func() error

	// SubscribeFunc mocks the Subscribe method.
	SubscribeFunc func(email Email) error

	// calls tracks calls to the methods.
	calls struct {
		// SendEmails holds details about calls to the SendEmails method.
		SendEmails []struct {
		}
		// Subscribe holds details about calls to the Subscribe method.
		Subscribe []struct {
			// Email is the email argument value.
			Email Email
		}
	}
	lockSendEmails sync.RWMutex
	lockSubscribe  sync.RWMutex
}

// SendEmails calls SendEmailsFunc.
func (mock *SubscriberMock) SendEmails() error {
	if mock.SendEmailsFunc == nil {
		panic("SubscriberMock.SendEmailsFunc: method is nil but Subscriber.SendEmails was just called")
	}
	callInfo := struct {
	}{}
	mock.lockSendEmails.Lock()
	mock.calls.SendEmails = append(mock.calls.SendEmails, callInfo)
	mock.lockSendEmails.Unlock()
	return mock.SendEmailsFunc()
}

// SendEmailsCalls gets all the calls that were made to SendEmails.
// Check the length with:
//
//	len(mockedSubscriber.SendEmailsCalls())
func (mock *SubscriberMock) SendEmailsCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockSendEmails.RLock()
	calls = mock.calls.SendEmails
	mock.lockSendEmails.RUnlock()
	return calls
}

// Subscribe calls SubscribeFunc.
func (mock *SubscriberMock) Subscribe(email Email) error {
	if mock.SubscribeFunc == nil {
		panic("SubscriberMock.SubscribeFunc: method is nil but Subscriber.Subscribe was just called")
	}
	callInfo := struct {
		Email Email
	}{
		Email: email,
	}
	mock.lockSubscribe.Lock()
	mock.calls.Subscribe = append(mock.calls.Subscribe, callInfo)
	mock.lockSubscribe.Unlock()
	return mock.SubscribeFunc(email)
}

// SubscribeCalls gets all the calls that were made to Subscribe.
// Check the length with:
//
//	len(mockedSubscriber.SubscribeCalls())
func (mock *SubscriberMock) SubscribeCalls() []struct {
	Email Email
} {
	var calls []struct {
		Email Email
	}
	mock.lockSubscribe.RLock()
	calls = mock.calls.Subscribe
	mock.lockSubscribe.RUnlock()
	return calls
}
