// ./cmd/main.go
package main

import (
	"context"
	"fmt"
	"github.com/delveper/gentest/domain/transport"
	"github.com/delveper/gentest/sys/config"
	"github.com/delveper/gentest/sys/logger"
	"net/http"
	"os"
	"os/signal"
	"time"
)

func main() {
	log := logger.New()
	defer log.Sync()

	if err := run(log); err != nil {
		log.Errorw("Startup error", "error", err)
		os.Exit(1)
	}
}

func run(log *logger.Logger) error {
	type Config struct {
		Repo struct {
			Path string `env:"DB_PATH"`
		}
		Mail struct {
			APIKey  string `env:"EMAIL_API_KEY"`
			Address string `env:"EMAIL_ADDRESS"`
		}
		Web struct {
			Host            string        `env:"API_HOST"`
			ReadTimeout     time.Duration `env:"API_READ_TIMEOUT"`
			WriteTimeout    time.Duration `env:"API_WRITE_TIMEOUT"`
			IdleTimeout     time.Duration `env:"API_IDLE_TIMEOUT"`
			ShutdownTimeout time.Duration `env:"API_SHUTDOWN_TIMEOUT"`
		}
	}

	cfg, err := config.ParseVars[Config]()
	if err != nil {
		return fmt.Errorf("parsing config: %v", err)
	}

	log.Infow("Starting service")

	shutdown := make(chan os.Signal, 1)
	signal.Notify(shutdown, os.Interrupt)

	api := transport.New(
		transport.Config{
			DBPath:       cfg.Repo.Path,
			EmailAPIkey:  cfg.Mail.APIKey,
			EmailAddress: cfg.Mail.Address,
		}, log)

	srv := http.Server{
		Addr:         cfg.Web.Host,
		Handler:      api.Handle(),
		ReadTimeout:  cfg.Web.ReadTimeout,
		WriteTimeout: cfg.Web.WriteTimeout,
		IdleTimeout:  cfg.Web.IdleTimeout,
		ErrorLog:     log.ToStandard(),
	}

	errSrv := make(chan error, 1)
	go func() {
		log.Infow("Startup", "status", "api router started", "host", srv.Addr)
		errSrv <- srv.ListenAndServe()
	}()

	select {
	case err := <-errSrv:
		return fmt.Errorf("server error: %w", err)

	case <-shutdown:
		log.Infow("Shutdown", "status", "shutdown started")
		defer log.Infow("Shutdown", "status", "shutdown complete")

		ctx, cancel := context.WithTimeout(context.Background(), cfg.Web.ShutdownTimeout)
		defer cancel()

		if err := srv.Shutdown(ctx); err != nil {
			srv.Close()
			return fmt.Errorf("shuting down gracefully: %w", err)
		}
	}

	return nil
}
// ./domain/rate/handler.go
package rate

import (
	"encoding/json"
	"github.com/delveper/gentest/sys/logger"
	"net/http"
)

type Getter interface {
	Get() (float64, error)
}

type Handler struct {
	rate Getter
	log  *logger.Logger
}

func NewHandler(rate Getter, log *logger.Logger) *Handler {
	return &Handler{
		rate: rate,
		log:  log,
	}
}

func (h *Handler) Rate(rw http.ResponseWriter, _ *http.Request) {
	rate, err := h.rate.Get()
	if err != nil {
		h.log.Errorw("Failed to get rate", "error", err) // 500
	}

	resp := struct{ Rate float64 }{Rate: rate}
	if err := json.NewEncoder(rw).Encode(resp); err != nil {
		h.log.Errorw("Writing response", "error", err) // 500
	}
}
// ./domain/rate/rate.go
package rate

import (
	"encoding/json"
	"fmt"
	"net/http"
)

type Service struct{}

func NewService() *Service {
	return &Service{}
}

func (a *Service) Get() (float64, error) {
	req, err := http.NewRequest(http.MethodGet, "https://api.coingecko.com/api/v3/exchange_rates", nil)
	if err != nil {
		return 0, fmt.Errorf("creating request: %w", err)
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return 0, fmt.Errorf("sending request: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return 0, fmt.Errorf("status code: %d", resp.StatusCode)
	}

	defer resp.Body.Close()

	rate := struct {
		Rates struct {
			UAH struct {
				Value float64
			}
		}
	}{}

	if err := json.NewDecoder(resp.Body).Decode(&rate); err != nil {
		return 0, fmt.Errorf("decoding response: %w", err)
	}

	return rate.Rates.UAH.Value, nil
}
// ./domain/subscription/handler.go
package subscription

import (
	"encoding/json"
	"errors"
	"github.com/delveper/gentest/sys/logger"
	"net/http"
	"net/mail"
)

type Subscriber interface {
	Subscribe(Email) error
	SendEmails() error
}

type Handler struct {
	sub Subscriber
	log *logger.Logger
}

func NewHandler(sub Subscriber, log *logger.Logger) *Handler {
	return &Handler{
		sub: sub,
		log: log,
	}
}

func toEmail(addr *mail.Address) Email {
	return Email{
		Address: *addr,
	}
}

// Subscribe subscribes to e-mails.
func (h *Handler) Subscribe(rw http.ResponseWriter, req *http.Request) {
	addr := req.FormValue("email")

	email, err := mail.ParseAddress(addr)
	if err != nil {
		h.log.Errorw("Invalid email", "error", err)
	}

	if err := h.sub.Subscribe(toEmail(email)); err != nil {
		h.log.Errorw("Subscription failed", "error", err)
		switch {
		case errors.Is(err, ErrEmailAlreadyExists):
			rw.WriteHeader(http.StatusConflict)
			resp := struct{ Error string }{Error: ErrEmailAlreadyExists.Error()}
			if err := json.NewEncoder(rw).Encode(resp); err != nil {
				h.log.Errorw("Writing response", "error", err)
			}
			return
		}
	}

	msg := struct{ Message string }{Message: "E-mail subscribed"}
	if err := json.NewEncoder(rw).Encode(msg); err != nil {
		h.log.Errorw("Writing response", "error", err)
	}
}

// SendEmails sends all e-mails stored in data base.
func (h *Handler) SendEmails(rw http.ResponseWriter, _ *http.Request) {
	if err := h.sub.SendEmails(); err != nil {
		h.log.Errorw("Subscription failed", "error", err)
	}

	msg := struct{ Message string }{Message: "E-mail sent"}
	if err := json.NewEncoder(rw).Encode(msg); err != nil {
		h.log.Errorw("Writing response", "error", err)
	}

	h.log.Infow("E-mails sent")
}
// ./domain/subscription/repository.go
package subscription

import (
	"errors"
	"io/fs"
)

type Storer interface {
	Store(name string, item Email) error
	FetchAll() ([]Email, error)
}

type Repo struct{ Storer }

func NewRepo(fileStore Storer) *Repo {
	return &Repo{fileStore}
}

func (s *Repo) Add(email Email) error {
	if err := s.Storer.Store(email.Address.String(), email); err != nil {
		if errors.Is(err, fs.ErrExist) {
			return ErrEmailAlreadyExists
		}
		return err
	}

	return nil
}

func (s *Repo) GetAll() ([]Email, error) {
	return s.Storer.FetchAll()
}
// ./domain/subscription/sender.go
package subscription

import (
	"fmt"
	"github.com/sendgrid/sendgrid-go"
	"github.com/sendgrid/sendgrid-go/helpers/mail"
	"net/http"
)

type Sender struct {
	address string
	apiKey  string
}

func NewSender(address, apiKey string) *Sender {
	return &Sender{apiKey: apiKey}
}

func (s *Sender) Send(email Email, rate float64) error {
	from := mail.NewEmail("Example Use", s.address)
	subject := "Current BTC to UAH rate"
	to := mail.NewEmail(email.Address.Name, email.Address.String())
	plainTextContent := "Current rate is:"
	htmlContent := fmt.Sprintf("<strong>%f</strong>", rate)
	message := mail.NewSingleEmail(from, subject, to, plainTextContent, htmlContent)

	client := sendgrid.NewSendClient(s.apiKey)

	resp, err := client.Send(message)
	if err != nil {
		return fmt.Errorf("sending email: %v", err)
	}

	if resp.StatusCode != http.StatusOK {
		return fmt.Errorf("expected OK, got: %d", resp.StatusCode)
	}

	return nil
}
// ./domain/subscription/subscription.go
package subscription

import (
	"errors"
	"net/mail"
)

var ErrEmailAlreadyExists = errors.New("email address is already in the database")

type Email struct {
	Address mail.Address
}

type EmailRepository interface {
	Add(Email) error
	GetAll() ([]Email, error)
}

type RateGetter interface {
	Get() (float64, error)
}

type EmailSender interface {
	Send(Email, float64) error
}

type Service struct {
	repo EmailRepository
	rate RateGetter
	mail EmailSender
}

func NewService(repo EmailRepository, rate RateGetter, mail EmailSender) *Service {
	return &Service{
		repo: repo,
		rate: rate,
		mail: mail,
	}
}

func (svc *Service) Subscribe(email Email) error {
	if err := svc.repo.Add(email); err != nil {
		return err
	}

	return nil
}

func (svc *Service) SendEmails() error {
	rate, err := svc.rate.Get()
	if err != nil {
		return err
	}

	emails, err := svc.repo.GetAll()
	if err != nil {
		return err
	}

	var errArr []error
	for _, email := range emails {
		err := svc.mail.Send(email, rate)
		if err != nil {
			errArr = append(errArr, err)
		}
	}

	if errArr != nil {
		return errors.Join(errArr...)
	}

	return nil
}
// ./domain/transport/http.go
package transport

import (
	"github.com/delveper/gentest/domain/rate"
	"github.com/delveper/gentest/domain/subscription"
	"github.com/delveper/gentest/sys/filestore"
	"github.com/delveper/gentest/sys/logger"
	"net/http"
)

type API struct {
	cfg Config
	log *logger.Logger
}

type Config struct {
	DBPath       string
	EmailAPIkey  string
	EmailAddress string
}

func New(cfg Config, log *logger.Logger) *API {
	return &API{
		cfg: cfg,
		log: log,
	}
}

// Handle return http.Handler with all application routes defined.
func (a *API) Handle() http.Handler {
	rateSvc := rate.NewService()
	rateHdl := rate.NewHandler(rateSvc, a.log)

	emailStore := filestore.New[subscription.Email](a.cfg.DBPath)
	emailRepo := subscription.NewRepo(emailStore)
	senderSvc := subscription.NewSender(a.cfg.EmailAPIkey, a.cfg.EmailAddress)
	subscriptionSvc := subscription.NewService(emailRepo, rateSvc, senderSvc)
	subscriptionHdl := subscription.NewHandler(subscriptionSvc, a.log)

	mux := http.NewServeMux()
	mux.Handle("/rate/", a.WithMethod(http.MethodGet)(rateHdl.Rate))
	mux.Handle("/subscribe/", a.WithMethod(http.MethodPost)(subscriptionHdl.Subscribe))
	mux.Handle("/sendEmails/", a.WithMethod(http.MethodPost)(subscriptionHdl.SendEmails))

	hdl := ChainMiddlewares(mux.ServeHTTP,
		a.WithLogRequest,
		a.WithCORS,
		a.WithJSON,
		a.WithoutPanic,
	)

	return hdl
}

// ./domain/transport/midleware.go
package transport

import (
	"net/http"
)

func ChainMiddlewares(hdl http.HandlerFunc, middlewares ...func(http.HandlerFunc) http.HandlerFunc) http.HandlerFunc {
	for i := len(middlewares) - 1; i >= 0; i-- { // LIFO
		hdl = middlewares[i](hdl)
	}

	return hdl
}

func (a *API) WithJSON(hdl http.HandlerFunc) http.HandlerFunc {
	return func(rw http.ResponseWriter, req *http.Request) {
		rw.Header().Set("Content-Type", "application/json; charset=UTF-8")
		hdl.ServeHTTP(rw, req)
	}
}

func (a *API) WithCORS(hdl http.HandlerFunc) http.HandlerFunc {
	return func(rw http.ResponseWriter, req *http.Request) {
		rw.Header().Set("Access-Control-Allow-Origin", req.Header.Get("Origin"))
		rw.Header().Set("Access-Control-Allow-Credentials", "false")
		rw.Header().Set("Access-Control-Allow-Headers", "Content-Type, Content-Length, Accept-Encoding, X-CSRF-Token")
		rw.Header().Set("Access-Control-Allow-Methods", "POST, GET")

		hdl.ServeHTTP(rw, req)
	}
}

// WithLogRequest logs every request and sends logger instance to further handler.
func (a *API) WithLogRequest(hdl http.HandlerFunc) http.HandlerFunc {
	return func(rw http.ResponseWriter, req *http.Request) {
		a.log.Debugw("Request:",
			"method", req.Method,
			"uri", req.RequestURI,
			"user-agent", req.UserAgent(),
			"remote", req.RemoteAddr,
		)

		hdl.ServeHTTP(rw, req)
	}
}

// WithoutPanic recovers in case panic, but we won't panic.
func (a *API) WithoutPanic(hdl http.HandlerFunc) http.HandlerFunc {
	return func(rw http.ResponseWriter, req *http.Request) {
		defer func() {
			if rec := recover(); rec != nil {
				a.log.Errorw("Recovered from panic.", "rec", rec)
				rw.WriteHeader(http.StatusInternalServerError)
				rw.Write([]byte(http.StatusText(http.StatusInternalServerError)))
			}
		}()

		hdl.ServeHTTP(rw, req)
	}
}

func (a *API) WithMethod(meth string) func(http.HandlerFunc) http.HandlerFunc {
	return func(hdl http.HandlerFunc) http.HandlerFunc {
		return func(rw http.ResponseWriter, req *http.Request) {
			if req.Method != meth {
				a.log.Errorw("Method not allowed", "method", meth)
				return
			}
			hdl.ServeHTTP(rw, req)
		}
	}
}
// ./sys/config/config.go
package config

import (
	"bufio"
	"fmt"
	"os"
	"reflect"
	"strconv"
	"strings"
	"time"
)

func LoadVars() (err error) {
	env, err := os.Open(".env")
	if err != nil {
		return fmt.Errorf("error during opening environment file: %w", err)
	}

	defer func() {
		if err = env.Close(); err != nil {
			err = fmt.Errorf("error during closing environment file: %w", err)
		}
	}()

	buf := bufio.NewScanner(env)
	buf.Split(bufio.ScanLines)

	for buf.Scan() {
		if keyVal := strings.Split(buf.Text(), "="); len(keyVal) > 1 {
			if err := os.Setenv(keyVal[0], keyVal[1]); err != nil {
				return fmt.Errorf("error during setting environment variable: %w", err)
			}
		}
	}

	return nil
}

func ParseVars[T any]() (*T, error) {
	if err := LoadVars(); err != nil {
		return nil, err
	}

	dst := new(T)
	val := reflect.ValueOf(dst).Elem()

	for i := 0; i < val.NumField(); i++ {
		field := val.Type().Field(i)

		if field.Type.Kind() == reflect.Struct {
			for j := 0; j < field.Type.NumField(); j++ {
				envTag := field.Type.Field(j).Tag.Get("env")
				if envTag != "" {
					envVal := os.Getenv(envTag)
					if envVal == "" {
						continue
					}

					switch field.Type.Field(j).Type.Kind() {
					case reflect.Int:
						integer, err := strconv.Atoi(envVal)
						if err != nil {
							return nil, err
						}
						val.Field(i).Field(j).SetInt(int64(integer))

					case reflect.Float64:
						float, err := strconv.ParseFloat(envVal, 64)
						if err != nil {
							return nil, err
						}
						val.Field(i).Field(j).SetFloat(float)

					case reflect.TypeOf(time.Duration(0)).Kind():
						duration, err := time.ParseDuration(envVal)
						if err != nil {
							return nil, err
						}
						val.Field(i).Field(j).Set(reflect.ValueOf(duration))

					default:
						val.Field(i).Field(j).SetString(envVal)
					}
				}
			}
		}
	}

	return dst, nil
}
// ./sys/filestore/filestore.go
package filestore

import (
	"encoding/json"
	"fmt"
	"io/fs"
	"log"
	"os"
	"path"
	"path/filepath"
	"reflect"
	"sync"
)

var ErrFileExists = fs.ErrExist

type FileStore[T any] struct {
	mu  sync.Mutex
	dir string
}

func New[T any](pth string) *FileStore[T] {
	name := reflect.TypeOf(*new(T)).Name()
	dir := path.Join(pth, name)

	return &FileStore[T]{
		dir: dir,
	}
}

func (f *FileStore[T]) Store(name string, item T) error {
	f.mu.Lock()
	defer f.mu.Unlock()
	if err := os.MkdirAll(f.dir, os.ModePerm); err != nil {
		return fmt.Errorf("creating path: %w", err)
	}

	pth := path.Join(f.dir, name)
	if info, err := os.Stat(pth); !os.IsNotExist(err) {
		log.Println(info)
		return ErrFileExists
	}

	file, err := os.Create(pth)
	if err != nil {
		return fmt.Errorf("creating JSON file: %w", err)
	}

	defer file.Close()

	if err := json.NewEncoder(file).Encode(item); err != nil {
		return fmt.Errorf("enconding JSON: %w", err)
	}

	return nil
}

func (f *FileStore[T]) FetchAll() ([]T, error) {
	f.mu.Lock()
	defer f.mu.Unlock()

	var coll []T

	walkFn := func(pth string, ent fs.DirEntry, err error) error {
		if err != nil {
			return fmt.Errorf("walking path: %w", err)
		}

		if !ent.IsDir() {
			file, err := os.Open(pth)
			if err != nil {
				return fmt.Errorf("opening file: %w", err)
			}
			defer file.Close()

			var item T
			if err := json.NewDecoder(file).Decode(&item); err != nil {
				return fmt.Errorf("decoding JSON: %w", err)
			}

			coll = append(coll, item)
		}

		return nil
	}

	if err := filepath.WalkDir(f.dir, walkFn); err != nil {
		return nil, err
	}

	return coll, nil
}
// ./sys/filestore/filestore_test.go
package filestore

import (
	"fmt"
	"os"
	"path"
	"testing"
)

type Email struct {
	Address string
}

func TestFileStore(t *testing.T) {
	tt := []struct {
		name         string
		testFunction func(t *testing.T)
	}{
		{name: "TestNew", testFunction: TestNew},
		{name: "TestStore", testFunction: TestStore},
		{name: "TestStoreFileExists", testFunction: TestStoreFileExists},
		{name: "TestFetchAll", testFunction: TestFetchAll},
	}

	for _, tc := range tt {
		t.Run(tc.name, tc.testFunction)
	}
}

func TestNew(t *testing.T) {
	fs := New[Email]("./tmp/test_path")
	defer func() {
		if err := os.RemoveAll("./tmp/test_path"); err != nil {
			t.Errorf("error while removing test_path: %v", err)
		}
	}()

	expectedDir := path.Join("./tmp/test_path", "Email")
	if fs.dir != expectedDir {
		t.Errorf("expected dir to be %s, got %s", expectedDir, fs.dir)
	}
}

func TestStore(t *testing.T) {
	fs := New[Email]("./tmp/test_path")
	defer func() {
		if err := os.RemoveAll("./tmp/test_path"); err != nil {
			t.Errorf("error while removing test_path: %v", err)
		}
	}()

	item := Email{Address: "test@example.com"}

	err := fs.Store("item1", item)
	if err != nil {
		t.Errorf("Error while storing item: %v", err)
	}

	if _, err := os.Stat(path.Join(fs.dir, "item1")); os.IsNotExist(err) {
		t.Errorf("File was not created")
	}
}

func TestStoreFileExists(t *testing.T) {
	fs := New[Email]("./tmp/test_path")
	defer func() {
		if err := os.RemoveAll("./tmp/test_path"); err != nil {
			t.Errorf("error while removing test_path: %v", err)
		}
	}()

	item := Email{Address: "test@example.com"}
	fs.Store("item1", item)

	err := fs.Store("item1", item)
	if err != ErrFileExists {
		t.Errorf("Expected ErrFileExists, got %v", err)
	}
}

func TestFetchAll(t *testing.T) {
	fs := New[Email]("./tmp/test_path")
	defer func() {
		if err := os.RemoveAll("./tmp/test_path"); err != nil {
			t.Errorf("error while removing test_path: %v", err)
		}
	}()

	items := []Email{
		{Address: "test1@example.com"},
		{Address: "test2@example.com"},
		{Address: "test3@example.com"},
	}

	for i, item := range items {
		err := fs.Store(fmt.Sprintf("item%d", i+1), item)
		if err != nil {
			t.Errorf("Error while storing item: %v", err)
		}
	}

	fetchedItems, err := fs.FetchAll()
	if err != nil {
		t.Errorf("Error while fetching all items: %v", err)
	}

	if len(fetchedItems) != len(items) {
		t.Errorf("Expected %d items, got %d", len(items), len(fetchedItems))
	}

	for i, item := range fetchedItems {
		if item.Address != items[i].Address {
			t.Errorf("Expected item at index %d to be %s, got %s", i, items[i].Address, item.Address)
		}
	}
}
// ./sys/logger/logger.go
package logger

import (
	"go.uber.org/zap"
	"go.uber.org/zap/zapcore"
	"log"
	"os"
)

// Logger is wrapper around *zap.SugaredLogger that will handle all logging behavior.
type Logger struct{ *zap.SugaredLogger }

func New() *Logger {
	core := zapcore.NewTee(getConsoleCore())
	return &Logger{zap.New(core).Sugar()}
}

func (l *Logger) ToStandard() *log.Logger {
	return zap.NewStdLog(l.Desugar())
}

func getConsoleCore() zapcore.Core {
	cfg := getEncoderConfig()
	cfg.EncodeLevel = zapcore.CapitalColorLevelEncoder

	return zapcore.NewCore(
		zapcore.NewConsoleEncoder(cfg),
		zapcore.Lock(os.Stderr),
		zapcore.DebugLevel,
	)
}

func getEncoderConfig() zapcore.EncoderConfig {
	return zapcore.EncoderConfig{
		MessageKey:          "message",
		LevelKey:            "level",
		TimeKey:             "time",
		NameKey:             "name",
		CallerKey:           "caller",
		FunctionKey:         "",
		StacktraceKey:       "stacktrace",
		SkipLineEnding:      false,
		LineEnding:          "\n",
		EncodeLevel:         zapcore.CapitalLevelEncoder,
		EncodeTime:          zapcore.ISO8601TimeEncoder,
		EncodeDuration:      zapcore.NanosDurationEncoder,
		EncodeCaller:        zapcore.ShortCallerEncoder,
		NewReflectedEncoder: nil,
		ConsoleSeparator:    "\t",
	}
}
